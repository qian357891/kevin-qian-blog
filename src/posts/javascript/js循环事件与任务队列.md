## 任务队列与事件循环

### 任务队列（消息队列）

 js是**单线程**的，单线程意味着所有的任务需要排队。在html5提出了web worker，允许开辟多线程，但是子线程不能操作dom，并且都由**主线程**控制（能够操作dom的线程）

任务分为**同步任务（synchronous）**和**异步任务（asynchronous）**。其中异步任务又分**宏任务（macro task 在新标准中叫task）和微任务（micro task 在新标准中叫jobs）**

同步任务会直接放到调用栈（call stack）中执行，而异步任务中的宏任务则会被放在**任务队列（task queue）**中，当任务队列通知该宏任务可以进入调用栈进行执行的时候，该宏任务才会进入调用栈执行。需要注意的是**微任务不会被分配到任务队列，而是微任务队列**



**同步任务先执行，注意：Promise构造函数中的代码也是同步任务**

微任务：Promise，async/await等  ，

宏任务：setTimeout，setInterval，DOM事件，AJAX请求等

微任务——>Dom渲染——>宏任务



注意：**宏任务队列==任务队列！=微任务队列**，也就是说微任务不会放入任务队列

（另一种解释：任务队列不是队列而是集合？）



执行顺序：

1.同步任务

2.process.nextTick

3.微任务

4.宏任务

5.setImmediate

### 事件循环

事件循环：可以理解为不断的检测任务队列里面有没有东西，只有在调用栈为空时，才会读取任务队列。

在事件循环中，并不是把所有微任务执行完后在执行所有的宏任务。而是通过事件循环的机制，不断“发现”微任务和宏任务。

每一次事件循环的任务执行顺序为：宏任务（**script标签也是宏任务**）——>（在调用栈为空时，事件循环优先执行微任务）微任务——>DOM渲染——>宏任务



**注意：1.每次单个宏任务执行完后都会检查微任务队列是否为空**

**2.每次宏任务产生的微任务队列都是新创建的,宏任务队列只有一个**



总结：js是单线程，事件循环从宏任务队列开始,一开始宏任务队列中只有一个script(整体代码)任务,遇到任务源时,分发到相应的任务队列中。

异步任务可分为macrotask（宏任务）和micrtask（微任务）两类。

不同的API注册的异步任务会依次进入自身对应的队列中，然后等待event loop 将他们依次压入执行栈中执行。执行栈执行完同步任务后，检查执行栈是否为空，如果为空，检查微任务队列是否为空，如果微任务队列不为空，则一次性执行完所有的微任务。如果微任务为空，则执行下一个宏任务。每次单个宏任务执行完之后，都会检查微任务队列是否为空，如果不为空，则会按照先进先出的方式执行完所有的微任务，然后执行下一个宏任务，以此循环。核心是每次宏任务产生的微任务队列都是新创建的 宏任务队列只有一个



setImmediate是当前事件循环结束后执行。