# TCP三次握手和四次挥手

[面试官，不要再问我三次握手和四次挥手 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/86426969)

![img](https://pic4.zhimg.com/80/v2-d8eb14056eb94ccef2f2de0bba774e7b_720w.webp)

#### 重要字段

- SEQ：**序号(sequence number)**：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
- ack：**确认号（acknowledgement number）**：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。
- **标志位（Flags）**：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：
- - URG：紧急指针（urgent pointer）有效。
  - ACK：确认序号有效。（为了与**确认号ack**区分开，我们用大写表示）
  - PSH：接收方应该尽快将这个报文交给应用层。
  - RST：重置连接。
  - SYN：发起一个新连接。
  - FIN：释放一个连接。



#### 11种状态名词解析

```
LISTEN：等待从任何远端TCP 和端口的连接请求。
 
SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。
 
SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。
 
ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。
 
FIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。
 
FIN_WAIT_2：等待远端TCP 的连接终止请求。
 
CLOSE_WAIT：等待本地用户的连接终止请求。
 
CLOSING：等待远端TCP 的连接终止请求确认。
 
LAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）
 
TIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。
TIME_WAIT 两个存在的理由：
          1.可靠的实现tcp全双工连接的终止；
          2.允许老的重复分节在网络中消逝。
 
CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）
```





#### 三次握手：建立连接

- C->S：客户端给服务端发送数据，服务端接收数据（服务端就能得出结论：客户端的发送能力、服务端的接收能力没问题）
- S->C：服务端给客户端发送数据（客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。）
- C->S：客户端收到数据，告诉服务端能收到（这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。）

打电话举例：

- C->S：喂，听得到吗？
- S->C：听得到，你听得到我吗？
- C->S：可以听到，我们可以说话了。

![img](https://pic2.zhimg.com/80/v2-b81bd261bd6ae2e3bf71e37853445039_720w.webp)



#### 四次挥手：断开连接

![img](https://pic1.zhimg.com/80/v2-1c2fa0e7ef3fe8bbe636cc08b2537630_720w.webp)

- C->S：客户端主动断开连接时，给服务端发送FIN报文`finish`，关闭客户端到服务端的数据传送。
- S->C：服务端给客户端发送报文，表示已经接收到报文。**（此时客户端就知道服务端接收到了自己的断开连接请求**），（**但是服务端可能还有数据要传输**）
- S->C：服务端发完数据后，再给客户端发送FIN报文`finish`，表示**不会再给客户端发送数据了。**
- C->S：客户端表示收到数据，给服务端发送数据确认收到。



举例：

**A给B发消息：“我打算关闭了！”**

**B给A回消息：“你的消息我收到了！但是我活还没干完，等我一会！”**

**B给A回消息：“好了，我活干完了！”**

**A给B发消息：“好的，我挂断了！”——同时等待一段时间后关闭**

**B收到消息后立即关闭**