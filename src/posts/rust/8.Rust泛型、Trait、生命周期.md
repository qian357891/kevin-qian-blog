---
date: 2022-12-17
category:
  - 后端
tag:
  - Rust
archive: true
---



# 8.Rust泛型、Trait、生命周期

> 我们在编写代码的时候需要考虑代码的复用性，通常情况下我们会使用提取函数和使用泛型来对代码进行复用

## 提取函数消除重复

### 重复代码

假如我们现在要比较出一个vector中的最大值，我们会这样写：

```rust
let list = vec![20, 44, 13, 22, 77, 8];
let mut largest_num = list[0];
for num in list {
    if largest_num < num {
        largest_num = num;
    }
}
println!("the largest number is {}", largest_num); //the largest number is 77
```

然后我们现在又要在另外一个Vector中挑出它的最大值：

```rust
let list = vec![20, 44, 13, 22, 77, 8];
let mut largest_num = list[0];
for num in list {
    if largest_num < num {
        largest_num = num;
    }
}
println!("the largest number is {}", largest_num); //the largest number is 77

let list = vec![200, 404, 103, 202, 77, 80];
let mut largest_num = list[0];
for num in list {
    if largest_num < num {
        largest_num = num;
    }
}
println!("the largest number is {}", largest_num); //the largest number is 404
```

我们发现有重复的代码（2-7和11-16），对于重复的代码：

- 容易出错
- 需求变更时需要在多处进行修改

为了消除重复，我们可以提取函数

```rust
fn largest_number(list: &[i32]) -> i32 {
    let mut largest_num = list[0];
    for &num in list {
        if largest_num < num {
            largest_num = num;
        }
    }
    largest_num
}
fn main() {
    let list = vec![20, 44, 13, 22, 77, 8];
    let largest = largest_number(&list);
    println!("the largest number is {}", largest); //the largest number is 77

    let list = vec![200, 404, 103, 202, 77, 80];
    let largest = largest_number(&list);
    println!("the largest number is {}", largest); //the largest number is 404
}
```

其中，传入的list类型为`&[i32]`实际上它是一个切片（我们必须传入引用，因为Rust不知道它的长度）。&num类型为i32，num类型为&i32。&num实际上进行了一个解构。我们如果不使用`&`，也可以在后面使用`*`进行解引用：

```rust
for num in list {
    if largest_num < *num {
        largest_num = *num;
    }
}
```



### 消除重复的步骤

- 识别重复代码

- 提取重复代码到函数体中，并在函数签名中指定函数的输入和返回值

- 将重复的代码使用函数调用进行替代



## 泛型

泛型：提高代码复用能力，也就是说可以处理重复代码的问题

泛型是具体类型或其它属性的抽象代替：

- 可以理解为：你使用泛型编写代码时不是最终的代码，而是一种**模板**，里面有一些**“占位符”**。
- 编译器在**编译时**将“占位符”**替换为具体的类型**（这个过程叫单态化）

例如：`fn largest<T>(list:&[T])->T{...}`

这个T被称为类型参数：

- 通常情况下很短，一般为一个字母，比如T（type的缩写）
- 在Rust中使用CamelCase大驼峰命名法



### 在函数定义中的泛型

在上面的例子中的比较大小只能用于i32类型，我们使用泛型来将其能用作比较字母的大小：

```rust
fn largest_number<T>(list: &[T]) -> T {
    let mut largest_num = list[0];
    for &num in list {
        if largest_num < num {//这里会报错，因为并不是所有类型都支持比较，我们需要给泛型指定Trait，这里先不管
            largest_num = num;
        }
    }
    largest_num
}
fn main() {
    let arr = [1, 3, 5, 7, 9];
    let list = vec![20, 44, 13, 22, 77, 8];
    let largest = largest_number(&list);
    println!("the largest number is {}", largest); //the largest number is 77

    let list = vec!['a', 's', 'e', 'b'];
    let largest = largest_number(&list);
    println!("the largest number is {}", largest); //the largest number is 404
}
```

上面的函数会报错，因为T没有实现`std::cmp::PartialOrd`这一Trait（接口interface），暂时先不管这个。



### Struct定义中的泛型

```rust
struct Point<T> {
    x: T,
    y: T,
}
fn main() {
    let integer = Point { x: 1, y: 2 }; //Point<i32>
    let float = Point { x: 1.0, y: 2.0 }; //Point<f64>
}
```

多个类型参数：

```rust
struct Point<T, U> {
    x: T,
    y: U,
}
fn main() {
    let float_int = Point { x: 1.0, y: 2 }; //Point<f64, i32>
}
```

如果太多类型参数，代码的可阅读性会变差，需要重组为多个更小的单元



### Enum中使用泛型

可以让枚举的变体持有泛型数据类型，例如我们之前用到的Option\<T>，Result\<T,E>

```rust
enum Option<T> {
    Some(T),
    None,
}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```



### 方法定义中的泛型

为struct或enum实现方法的时候，可在定义中使用泛型

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

impl Point<i32> {
    fn x1(&self) -> &i32 {
        &self.x
    }
}
```

如果impl是根据Point\<T>来实现的（在类型T上实现方法），我们需要在impl后加\<T>。如果这个T是一个确切的类型，比如i32，我们就不需要加泛型T



另外，struct里的泛型类型参数可以和方法的泛型类型参数不同

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mix<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2.3 };
    let p2 = Point { x: 'a', y: "demo" };
    let p3 = p1.mix(p2);
    println!("x:{},y:{}", p3.x, p3.y); //x:1,y:demo
}
```

在上面的例子中，我们Point的类型参数为T，U，impl实现的也是T，U。而我们的mix函数的泛型的类型参数为V，W。

上面mix方法的意思为接收一个<T,U>类型的Point，接收另一个Point，不过这里是占位符为V，W（类型参数）。然后返回的Point的x为self的x。而y为另一个Point的y。类型为：<自身x的类型，other中y的类型>



### 泛型代码的性能

使用泛型的代码和使用具体类型的代码运行速度是一样的。

这是因为Rust在编译时会执行**单态化**（monomorphization）的过程：

- 在编译时将泛型类型替换为具体类型的过程

```rust
fn main() {
    let integer = Some(5);
    let floater = Some(5.0);
}
```

上面的代码会被编译为这样（编译为具体的类型）：

```rust
enum Option_i32 {
    Some(i32),
    None,
}
enum Option_f64 {
    Some(f64),
    None,
}
fn main() {
    let integer = Option_i32::Some(5);
    let floater = Option_f64::Some(5.0);
}
```



## Trait（特质、特征）

Trait告诉Rust编译器：

- 某种类型具有哪些并且可以与其他类型共享的功能

Trait：抽象的定义共享行为

Trait bounds（约束）：泛型类型参数指定为实现了特定行为的类型

Trait与其他语言的接口（interface）类似，但也有区别。



### 定义一个Trait

Trait的定义：把方法签名放在一起，来定义实现某种目的所必须的一组行为。

- 关键字：trait
- 只有方法签名，没有具体实现
- trait可以有多个方法：每个方法签名占一行，以`;`结尾
- 实现该trait的类型必须提供具体的方法实现

```rust
pub trait CopyArticle {
    fn copy(&self) -> String;
    fn copy1(&self) -> String;
}
```



### 在类型上实现trait

与为类型实现方法类似。

不同之处：

- impl **Xxxx for** Tweet{...}  （Xxxx是trait名）
- 在`impl`的块里，需要对Trait里的方法签名进行具体的实现

src/lib.rs

```rust
pub trait CopyArticle {
    fn copy(&self) -> String;
}

pub struct Jps {
    pub auther: String,
    pub title: String,
    pub content: String,
}

impl CopyArticle for Jps {
    fn copy(&self) -> String {
        format!(
            "title:{},content:{},auther:{}",
            self.title, self.content, self.auther
        )
    }
}

pub struct Book {
    pub auther: String,
    pub book_name: String,
}

impl CopyArticle for Book {
    fn copy(&self) -> String {
        format!("book_name is {},auther is {}", self.book_name, self.auther)
    }
}
```

src/main.rs

```rust
use panic::Book;//panic是Cargo.toml中的[package]的name
use panic::CopyArticle;
use panic::Jps;
fn main() {
    let book = Book {
        book_name: String::from("nice demo"),
        auther: String::from("Kevin"),
    };
    println!("{}", book.copy()); //book_name is nice demo,auther is Kevin
    let jps = Jps {
        title: String::from("demo_title"),
        content: String::from("this is a content"),
        auther: String::from("Kevin"),
    };
    println!("{}", jps.copy()); //title:demo_title,content:this is a content,auther:Kevin
}
```

我们在lib.rs中声明了trait和struct后在其他文件使用需要使用`use`导入。包名为Cargo.toml中的[package]的name



### 实现trait的约束

可以在某个类型上实现某个trait的前提条件是：

- 这个类型或者trait是在本地create里定义的

我们无法为外部类型来实现外部的trait：

- 这个限制是程序属性的一部分（也就是**一致性**）
- 更具体的说是**孤儿原则**：之所以这样命名是因为父类型不存在
- 此规则确保其他人的代码不能破坏你的代码，反之亦然
- 如果没有这个规则，两个create可以为同一类型实现同一个trait，Rust就不知道用哪个实现了



### 默认实现

我们可以在trait中默认实现方法，我们在上面的例子中做一些改变：

lib.rs

```rust
pub trait CopyArticle {
    // fn copy(&self) -> String;
    fn copy(&self) -> String {
        String::from("defualt")
    }
}
//...
impl CopyArticle for Jps {}
//...
impl CopyArticle for Book {
    //这里重写了copy方法
    fn copy(&self) -> String {
        format!("book_name is {},auther is {}", self.book_name, self.auther)
    }
}
```

main.rs

```rust
//...
println!("{}", jps.copy()); //defualt
//...
println!("{}", book.copy()); //book_name is nice demo,auther is Kevin
```



默认实现的方法可以调用trait中其他的方法，即使这些方法没有默认实现

```rust
pub trait CopyArticle {
    fn copy_dont(&self) -> String;
    fn copy(&self) -> String {
        format!("defualt,and more: {}", self.copy_dont())
    }
}
//...
impl CopyArticle for Jps {
    //需要实现没有默认实现的才能正常使用
    fn copy_dont(&self) -> String {
        format!(
            "title:{},content:{},auther:{}",
            self.title, self.content, self.auther
        )
    }
}
```



**注意：无法从方法的重写实现里面调用默认的实现**，比如这样：

```rust
pub trait CopyArticle {
    fn copy(&self) -> String {
        String::from("sss")
    }
}
//...
impl CopyArticle for Jps {
    fn copy(&self) -> String {
        format!("yes more: {}", self.copy())//不允许这样做
    }
}
```



### Trait作为参数（类型）

比如我们现在要封装一个方法，在方法中要使用trait的方法，我们可以这样做：

使用impl Trait语法：适用于简单语法

```rust
pub trait CopyArticle {
    fn copy(&self) -> String;
}
//...
fn a_func(item: impl CopyArticle) {
    println!("{}", item.copy());
}
```

Trait bound语法（使用泛型）：可用于复杂情况

```rust
//impl Trait语法
fn a_func1(item1: impl CopyArticle, item2: impl CopyArticle) {
    println!("{},{}", item1.copy(), item2.copy());
}

//Trait bound语法
fn a_func2<T: CopyArticle>(item1: T, item2: T) {
    println!("{},{}", item1.copy(), item2.copy());
}
```

实际上，impl Trait语法的Trait bound的语法糖

使用`+`指定多个Trait bound：

```rust
fn a_func1(item1: impl CopyArticle + Display) {
    println!("{}", item1.copy());
}

fn a_func2<T: CopyArticle + Display>(item1: T) {
    println!("{}", item1.copy());
}
```



我们指定多个Trait bound可能会出现函数签名过于累赘，影响代码的可读性，比如像这样：

```rust
fn a_func1<T: CopyArticle + Display, U: Debug + Clone>(item1: T, item2: U) -> String {
    format!("nice yes {}", item1.copy())
}
```

我们可以使用Trait bound使用**where**子句：

```rust
fn a_func2<T, U>(item1: T, item2: U) -> String
where
    T: CopyArticle + Display,
    U: Debug + Clone,
{
    format!("nice yes {}", item1.copy())
}
```

这个时候我们发现，函数签名的可读性就非常好了。

其中，where子句在函数签名的返回类型后。



### 实现Trait作为返回类型

使用impl Trait语法

```rust
fn a_func2() -> impl CopyArticle {
    Book {
        auther: String::from("kevin"),
        book_name: String::from("yes nice"),
    }
}
```

**但是，需要注意的是：返回的类型必须确定的同一类型，返回可能不同的类型会报错**

下面的代码将会报错，因为：虽然它们都实现了`CopyArticle`这个Trait，但是这个函数可能返回的类型是不同的类型，所以会报错。

```rust
//会报错
fn a_func2(boolean: bool) -> impl CopyArticle {
    if boolean {
        Book {
            auther: String::from("kevin"),
            book_name: String::from("yes nice"),
        }
    } else {
        Jps {
            auther: String::from("kevin"),
            title: String::from("yes nice"),
            content: String::from("ooo ooo ooo"),
        }
    }
}
```



### 使用Trait Bound的例子

我们使用Trait Bound来修复之前找出最大值largest函数的报错：



